from math import log
import numpy as np
from random import randint

class RANSAC:
    '''the default maximum euclidian distance between a transformed point and the point to which it is matching
    for it to be considered an inlier'''
    DEFAULT_INLIER_THRESHOLD = 40#12

    '''uses the RANSAC algorithm to determine the best features to create a transformation matrix from.

    align_solver is an AlignSolver subclass. Answer_confidence is the confidence the algorithm uses to determine
    the number of times RANSAC should run to answer with a confidence that is inputted that the answer it returns
    is correct'''
    def __init__(self, feature_matches, align_solver, inlier_threshold = None):
        self.inlier_threshold = RANSAC.DEFAULT_INLIER_THRESHOLD if inlier_threshold == None else inlier_threshold
        self.align_solver = align_solver
        self.feature_matches = feature_matches
        self.num_iter = None

    '''
    To add: a good way to set a "minimum" number of inliers for an image to be deemed able to be well-mosaiced with another
    '''
    def set_params(self, params):
        self.num_iter = params["num_iter"]
        self.inlier_cutoff = params["inlier_cutoff"]

    '''
    fits the ransac model to find the model with optimal "agreement" with the feature_matches'''

    '''possible addition: Whenever a new high-scorer is found, form random samples but keep
    some samples from that high-scorer constant. This may allow for higher scores based on the fact that some
    subset of the previous high-scorer is correct but the remaining are not.'''

    def fit(self):
        best_fit_align_solve = None
        best_fit_align_score = None
        for iter in range(0, self.num_iter):
            random_solve_sample = self.sample_matches()
            iter_align_solve = self.align_solver(random_solve_sample, self.feature_matches)
            iter_inlier_score = self.get_inlier_score(iter_align_solve)
            if best_fit_align_score == None or iter_inlier_score > best_fit_align_score:
                print("better inlier score found: ", iter_inlier_score)
                best_fit_align_score = iter_inlier_score
                best_fit_align_solve = iter_align_solve
                if best_fit_align_score > self.inlier_cutoff:
                    break

        return best_fit_align_solve
        return None

    '''randomly samples N points from feature_matches where N is based on the "NUM_SOLVE_FEATURES" static abstract parameter of
    self.align_solver'''
    def sample_matches(self):
        feature_matches_clone = list(self.feature_matches)
        rand_features = []

        for i in range(0, self.align_solver.NUM_SOLVE_FEATURES()):
            rand_index = randint(0, len(feature_matches_clone)-1)
            rand_features.append(feature_matches_clone[rand_index])
            del feature_matches_clone[rand_index]
        return rand_features

    '''returns the AlignSolve object's inlier score, the number of inliers that the transformation matrix generated by the object
    "agree" with'''
    def get_inlier_score(self, align_solve):
        transformed_match_pairs = align_solve.get_transformed_match_pairs()
        num_inliers = 0
        for i in range(0, len(transformed_match_pairs)):
            if self.match_pair_is_inlier(transformed_match_pairs[i]):
                num_inliers += 1
        return num_inliers

    '''returns whether the pair of match points after transformation is close enough to be determined an inlier'''
    def match_pair_is_inlier(self, match_pair):
        return np.linalg.norm(match_pair[1] - match_pair[0]) < self.inlier_threshold

    '''
    ISSUE: Very likely incorrect calculation. Until this is fixed, the RANSAC class will only take a num_iter argument
    instead of calculating the number of iterations probabilistically

    SOLUTION???: Probably did not work because I did not specify the base for log. Should (I think) be log base NUM_SOLVE_FEATURES

    sets the variable "num_iter" which is determined by estimating the number of times the algorithm needs to run
    for it to find the best answer with "answer_confidence" percent confidence using the fact that:
        (1-proportion_estimated_inliers)^(run_times) <= likelihood of not finding the best answer
        '''
    def init_min_num_iter(self):
        self.num_iter = int(log(1-self.answer_confidence)/log(1-self.proportion_estimated_inliers))
